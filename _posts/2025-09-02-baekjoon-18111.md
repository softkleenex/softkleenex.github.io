---
title:  "백준 18111-마인크래프트"
excerpt: "baekjoon 18111-마인크래프트"

categories:
  - Blog
tags:
  - [baekjoon]

toc: true
toc_sticky: true
 
date: 2025-09-02
last_modified_at: 2025-09-02
---


문제
팀 레드시프트는 대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 × 1 × 1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.


목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’ 작업을 해야 한다.


lvalue는 세로 N, 가로 M 크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.


좌표 (i, j)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.


인벤토리에서 블록 하나를 꺼내어 좌표 (i, j)의 가장 위에 있는 블록 위에 놓는다.


1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’ 작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.

단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는 B개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.

입력
첫째 줄에 N, M, B가 주어진다. (1 ≤ M, N ≤ 500, 0 ≤ B ≤ 6.4 × 107)

둘째 줄부터 N개의 줄에 각각 M개의 정수로 땅의 높이가 주어진다. (i + 2)번째 줄의 (j + 1)번째 수는 좌표 (i, j)에서의 땅의 높이를 나타낸다. 땅의 높이는 256보다 작거나 같은 자연수 또는 0이다.

출력
첫째 줄에 땅을 고르는 데 걸리는 시간과 땅의 높이를 출력하시오. 답이 여러 개 있다면 그중에서 땅의 높이가 가장 높은 것을 출력하시오.

예제 입력 1 


3 4 99


0 0 0 0


0 0 0 0


0 0 0 1


예제 출력 1 


2 0


맨 오른쪽 아래의 블록을 제거하면 모두 높이가 0으로 고른 상태가 된다. 따라서 블럭을 한 번 제거하는 시간 2초가 소요된다.

예제 입력 2 


3 4 1


64 64 64 64


64 64 64 64


64 64 64 63


예제출력 2 


1 64


예제 입력 3 


3 4 0


64 64 64 64


64 64 64 64


64 64 64 63


예제 출력 3 


22 63


인벤토리가 비어 있기 때문에, 맨 오른쪽 아래를 제외한 모든 좌표에서 블록을 하나씩 제거해야 한다.

---
풀이 


문제를 풀때 가장 어려웠던건, 블록을 정리하는 프로세스의 구현이다.

무엇을 기준으로 잡아야하는지 조차도 몰랐는데, https://www.acmicpc.net/problem/18111

이 블로그를 통하여  아주 작은 범위인 [0, 256] 높이를 기준으로 잡는 풀이를 떠올렸다.

평탄화 작업에서 신경쓰였던 것은,

보유 블럭 : 0

목표 높이 : 1일때에

[0 2]

이면 0은 psss, 2를 하나 줄이고,

0을 다시 쌓아야 하는 경우가 있기 떄문에, 아래의 방식으로 생각하였다.


```
while 1:

    블록정리 프로세스

    if 블록 정리 진척없으면

        break
```


이런식으로 하였는데, 이 경우는 (m * n)의 깊은 복사가 여러번 일어나게 되어 비효율적이다.



이때는 claude code의 도움을 받았다,

각 프로세스마다 땅의 영역이 서로 영향을 받지 않고, 

각 땅의 영역이 고려하는것은 보유 블럭, 목표 높이 뿐이기에 while문을 통하여 실제로 평탄화를 할 필요조차 없었다.


---
```python
#https://www.acmicpc.net/problem/18111

import sys
input = sys.stdin.readline

n, m, b = map(int, input().split())#세로 가로 블록 수

grounds = list(list(map(int, input().split()))
               for i in range(n) )



t = 0

ans = [sys.maxsize, -1]#시간,높이


for h in range(0, 256 + 1):
    need_block = 0
    removed_block = 0
    

    for i1, v1 in enumerate(grounds):
        for i2, v2 in enumerate(v1):

            if v2 > h:#현재블록의 높이가 목표 높이보다 크다면 
                removed_block += grounds[i1][i2] - h
            
            else: #현재 블록의 높이가 목표 높이보다 낮다면
                need_block += h - grounds[i1][i2]
    
    if need_block <= removed_block + b:#필요 블럭이 가지게 되는 블럭보다 적다면, 즉 h에 도달하는것이 가능하다면
        t = removed_block * 2 + need_block * 1
        ans = [t, h] if (ans[0] > t or (ans[0] == t and ans[1] <= h)) else ans
                
    
print(*ans)




    

#어떻게 하지,, 하다가 https://aia1235.tistory.com/25 이 블로그를 보고 높이기준으로 하는 발상을 떠올림

```