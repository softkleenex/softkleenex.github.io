---
title:  "백준 30812-별자리가 될 수 있다면"
excerpt: "30821 - 별자리가 될 수 있다면"

categories:
  - Blog
tags:
  - [baekjoon]

toc: true
toc_sticky: true
 
date: 2025-08-29
last_modified_at: 2025-08-29
---


문제
곧 시계는 6시, 벌써 첫 번째 별이 보인다. 정$N$각형 모양의 하늘에는 몇 개의 별이 뜰 수 있을까?

정$N$각형의 꼭짓점의 개수 $N$이 주어졌을 때, 정$N$각형의 꼭짓점을 이어 만들 수 있는 서로 다른 별의 개수를 출력하여라.

별은 정$N$각형의 다섯 꼭짓점에 시계 방향으로 번호를 붙였을 때, 그 꼭짓점들을 1-3-5-2-4-1 순으로 연결한 것을 의미한다. 뒤집거나 돌려서 같은 모양이 나오는 별도 정$N$각형의 다른 꼭짓점을 이어 만든 별이라면 서로 다른 별이다.

입력
정$N$각형의 꼭짓점의 개수인 정수 $N$이 주어진다. $(5\leq N \leq 100)$ 

출력

정$N$각형의 꼭짓점을 이어 만들 수 있는 별의 개수를 출력한다.

예제 입력 1 

6

예제 출력 1 

6

예제 입력 2

100

예제 출력 2 

75287520


---
풀이 방법

N C 5가 정답인것은 바로 알았다.
itertools를 이용해야하는것은 어렴풋이 기억해서, help와 dir을 써가며 itertools.combinations를 사용해 보았다.
len(itertools.combinations(range(n), 5)) 를 사용하였지만, itertools.combinations의 반환값은 iteraotr(반복 가능한 객체 한번에 생성)이 아니라 generator(반복 가능한 객체 순차적으로 생성)이기에 len을 사용할 수 없었다.

combo_list = list(itertools.combinations(range(n), 5))
length = len(combo_list)  # 작동함!
이런식으로 제네레이터를 list로 감싸 처리하거나, 
length = sum(1 for _ in itertools.combinations(range(n), 5))
이런식으로 제네레이터 하나당 +1 하여 Len을 흉내 낼 수는 있겠지만, 더 효율적인 방법을 찾고 싶었다.
claude를 이용했고, math.comb(조합) 와 math.perm(순열)을 알아냈다.
math.X로는 순열, 조합의 개수만을 리턴하여 더 간단하다.

다만 itertools.comb <> math.comb, itertools.permutations <> math.perm은 해결했지만,
itertools.comb_with_replacement
itertools.product 도 math로 해결 할 수는 없을까??

itertools.comb_with_replacement(range(a), b) 는  a ** b or pow(a, b)로,

itertools.combinations_with_replacement(range(a), b)는 math.comb(n + r - 1, r)로 해결 가능했다.

---
```python
import sys
import itertools
import math

input = sys.stdin.readline

n = int(input())

# print(help(math.comb))


print(math.comb(n, 5))
#n C 5 
```